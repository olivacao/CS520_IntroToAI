import java.util.*;

public class AStar extends SearchAlgorithm{

    private static int EUCLIDEAN_DISTANCE = 0;
    private static int MANHATTAN_DISTANCE = 1;

    private int heurisitic;
    private Maze maze;

    private int length = 0;
    private int maxFringe = Integer.MIN_VALUE;
    private int expanded = 0;
    private boolean isSolvable = false;

    public AStar(Maze maze, int heuristic) {
        this.maze = maze;
        this.heurisitic = heuristic;
        maze.initialize();
        solveMaze();
    }

    public boolean solveMaze() {
        maze.initialize();
        PriorityQueue<Node> pq = new PriorityQueue<>(new Comparator<Node>() {
            @Override
            public int compare(Node o1, Node o2) {
                if (o1.getF() == o2.getF()) {
                    return 0;
                } else if (o1.getF() < o2.getF()) {
                    return -1;
                } else {
                    return 1;
                }
            }
        });

        // initialize H
        for (int i = 0; i < maze.getDim(); i++) {
            for (int j = 0; j < maze.getDim(); j++) {
                if (heurisitic == MANHATTAN_DISTANCE) {
                    maze.getMaze()[i][j].setH(Math.abs(maze.getDim() - 1 - i) + Math.abs(maze.getDim() - 1 - j));
                } else if (heurisitic == EUCLIDEAN_DISTANCE){
                    maze.getMaze()[i][j].setH(Math.sqrt((maze.getDim() - 1 - i)*(maze.getDim() - 1 - i) + (maze.getDim() - 1 - j)*(maze.getDim() - 1 - j)));
                }
            }
        }
        pq.add(maze.getMaze()[0][0]);
        int step = 0;
        maze.getMaze()[0][0].setG(step);

        while (!pq.isEmpty()) {
            maxFringe = Math.max(maxFringe, pq.size());
            Node node = pq.poll();
            node.setVisited(true);
            int row = node.getRow();
            int col = node.getCol();
            expanded++;
            helper(row - 1, col, pq, node, step);
            helper(row + 1, col, pq, node, step);
            helper(row, col - 1, pq, node, step);
            helper(row, col + 1, pq, node, step);


            if (pq.contains(maze.getMaze()[maze.getDim() - 1][maze.getDim() - 1])) {
                isSolvable = true;
//                System.out.println("Solvable: true");
                getRoute();
                return true;
            }
        }
//        System.out.println("Solvable: false");

        return isSolvable;
    }

    private void helper(int row, int col, PriorityQueue<Node> pq, Node node, int step) {
        if (row >= 0 && row < maze.getDim() && col >= 0 && col < maze.getDim() && !maze.getMaze()[row][col].isOccupied() && !maze.getMaze()[row][col].isVisited()) {
            Node tmp = maze.getMaze()[row][col];
            if (pq.contains(tmp)) {
                if (tmp.getG() > node.getG() + 1) {
                    tmp.setPrev(node);
                    tmp.setG(node.getG() + 1);
                }
            } else {
                pq.add(tmp);
                tmp.setPrev(node);
                tmp.setG(node.getG() + 1);
            }

        } else {

        }
    }

    /**
     * Get the routes from the last node.
     */
    public Stack<Node> getRoute() {
        Node node = maze.getMaze()[maze.getDim() - 1][maze.getDim() - 1];
        length = 1;
        Stack<Node> stack = new Stack<>();
        while (node.getPrev() != null) {
            stack.push(node);
            length++;
            node = node.getPrev();
        }
        stack.push(node);
//        printRoute(stack);
        return stack;
    }

    /**
     * Print the route using a node stack generated by the getRoute() function.
     * @param stack
     */
    public int[][] printRoute(Stack<Node> stack) {
//        System.out.println("Route: ");
//        while (!stack.isEmpty()) {
//            Node node = stack.pop();
//            System.out.println(node.getRow() + ", " + node.getCol());
//    }

        int[][]arr=this.maze.toArray();
        System.out.println("Route: ");
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            arr[node.getRow()][node.getCol()]=8;
        }

//        MazeDrawer mazeDrawer = new MazeDrawer();
//        mazeDrawer.drawMaze(arr);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++)
                sb.append(arr[i][j]).append(" ");
            sb.append("\n");
        }
        System.out.println(sb.toString());
        return arr;
    }

    public int getExpanded() {
        if (!isSolvable) {
            return -1;
        }
        return expanded;
    }

    public int getMaxFringe() {
        return maxFringe;
    }

    public int getLength() {
        return length;
    }

    public boolean isSolvable() {
        return isSolvable;
    }
}

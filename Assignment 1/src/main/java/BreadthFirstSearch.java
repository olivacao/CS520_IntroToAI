import java.util.*;

public class BreadthFirstSearch extends SearchAlgorithm{
    private Maze maze;
    private Queue<Node> queue;
    private int length = 0;
    private int maxFringe = Integer.MIN_VALUE;
    private int expanded = 0;
    private boolean isSolvable = false;

    public BreadthFirstSearch(Maze maze) {
        this.maze = maze;
        this.queue = new LinkedList<>();
        maze.initialize();
        solveMaze();
    }

    public boolean solveMaze() {
        queue.add(maze.getMaze()[0][0]);

        while (!queue.isEmpty()) {
            Node tmp = queue.poll();
            tmp.setVisited(true);
            expanded++;
            maxFringe = Math.max(maxFringe, queue.size());
            int row = tmp.getRow();
            int col = tmp.getCol();
            if (row == maze.getDim() - 1 && col == maze.getDim() - 1) {
                isSolvable = true;
                break;
            }

            if (isValid(row + 1, col)) {
                maze.getMaze()[row + 1][col].setPrev(tmp);
                queue.add(maze.getMaze()[row + 1][col]);
            }

            if (isValid(row, col + 1)) {
                maze.getMaze()[row][col + 1].setPrev(tmp);
                queue.add(maze.getMaze()[row][col + 1]);
            }

            if (isValid(row - 1, col)) {
                maze.getMaze()[row - 1][col].setPrev(tmp);
                queue.add(maze.getMaze()[row - 1][col]);
            }

            if (isValid(row, col - 1)) {
                maze.getMaze()[row][col - 1].setPrev(tmp);
                queue.add(maze.getMaze()[row][col - 1]);
            }
        }
//        System.out.print("Solvable: ");
        if (isSolvable) {
//            System.out.print("true\n\n");
            getRoute();
        } else {
//            System.out.println("false\n\n");
        }
        return isSolvable;
    }

    /**
     * Determine if a pair of given coordinates is valid,
     * the coordinates should be in a valid range, not occupied and not been visited before.
     * @param i
     * @param j
     * @return
     */
    private boolean isValid(int i, int j) {
        if (i >= 0 && i < maze.getDim() && j >= 0 && j < maze.getDim() && !maze.getMaze()[i][j].isOccupied() && !maze.getMaze()[i][j].isVisited() && !queue.contains(maze.getMaze()[i][j])) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Get the routes from the last node.
     */
    public Stack<Node> getRoute() {
        Node node = maze.getMaze()[maze.getDim() - 1][maze.getDim() - 1];
        length = 1;
        Stack<Node> stack = new Stack<>();
        while (node.getPrev() != null) {
            stack.push(node);
            length++;
            node = node.getPrev();
        }
        stack.push(node);
        return stack;
//        printRoute(stack);
    }

    public int getExpanded() {
        if (!isSolvable) {
            return -1;
        }
        return expanded;
    }

    public int getMaxFringe() {
        return maxFringe;
    }

    public int getLength() {
        return length;
    }

    public boolean isSolvable() {
        return isSolvable;
    }

    /**
     * Print the route using a node stack generated by the getRoute() function.
     * @param stack
     */
    public int[][] printRoute(Stack<Node> stack) {
//        System.out.println("Route: ");
//        while (!stack.isEmpty()) {
//            Node node = stack.pop();
//            System.out.println(node.getRow() + ", " + node.getCol());
//        }
        int[][]arr=this.maze.toArray();
        System.out.println("Route: ");
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            arr[node.getRow()][node.getCol()]=8;
        }

//        MazeDrawer mazeDrawer = new MazeDrawer();
//        mazeDrawer.drawMaze(arr);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++)
                sb.append(arr[i][j]).append(" ");
            sb.append("\n");
        }
        System.out.println(sb.toString());
        return arr;
    }

}
